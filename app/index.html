<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>실시간 자막</title>
<style>
  :root{ --fg:#fff; --glass:rgba(0,0,0,.35); --shadow:rgba(0,0,0,.55);
         --accent1:#c9a6ff; --accent2:#7ad7ff; --radius:18px; }
  html,body{height:100%;margin:0}
  body{
    display:flex; 
    flex-direction: column;
    background: transparent;
    color:var(--fg);
    font-family: "Malgun Gothic","맑은 고딕","Apple SD Gothic Neo","Nanum Gothic",sans-serif;
    overflow:hidden;
  }
  :lang(en), .en{ font-family: Arial, Helvetica, sans-serif; }
  
  .controls{
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 8px;
    align-items: center;
    z-index: 100;
    -webkit-app-region: no-drag;
  }
  
  .close-btn{
    background:rgba(255,50,50,.5);
    border-radius:6px; 
    border:none;
    color:#fff; 
    padding:6px 10px; 
    cursor:pointer;
    transition: background .2s;
    font-size: 0.9rem;
  }
  
  .close-btn:hover{
    background:rgba(255,50,50,.7);
  }
  
  .opacity-control{
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 10px;
    background: rgba(0,0,0,.5);
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,.2);
  }
  
  .opacity-control label{
    font-size: 0.8rem;
    opacity: 0.9;
  }
  
  .opacity-control input[type="range"]{
    width: 80px;
    height: 4px;
    background: rgba(255,255,255,.3);
    border-radius: 2px;
    outline: none;
    -webkit-appearance: none;
  }
  
  .opacity-control input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance: none;
    width: 12px;
    height: 12px;
    background: linear-gradient(135deg, var(--accent1), var(--accent2));
    border-radius: 50%;
    cursor: pointer;
  }
  
  .opacity-control input[type="range"]::-moz-range-thumb{
    width: 12px;
    height: 12px;
    background: linear-gradient(135deg, var(--accent1), var(--accent2));
    border-radius: 50%;
    border: none;
    cursor: pointer;
  }
  
  .opacity-control span{
    font-size: 0.8rem;
    min-width: 25px;
    text-align: right;
    opacity: 0.9;
  }
  
  .server-status{
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 10px;
    background: rgba(0,0,0,.5);
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,.2);
  }
  
  .server-indicator{
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #ff3232;
    transition: background 0.3s ease;
    box-shadow: 0 0 8px rgba(255, 50, 50, 0.5);
  }
  
  .server-indicator.connected{
    background: #4caf50;
    box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
  }
  
  .server-status label{
    font-size: 0.8rem;
    opacity: 0.9;
  }
  
  .content{
    flex: 1;
    display:flex; 
    align-items:flex-end; 
    justify-content:center;
    overflow:hidden;
  }
  
  .wrap{
    position: relative;
    width:min(92vw,1100px); 
    margin:0 auto 10vh; 
    padding:0 12px;
    -webkit-app-region: drag;
  }
  
  .panel{
    background:var(--glass);
    backdrop-filter:blur(10px);
    -webkit-backdrop-filter:blur(10px);
    border-radius:var(--radius); 
    box-shadow:0 4px 12px rgba(0,0,0,.3);
    border: 1px solid rgba(255,255,255,.15);
    padding: clamp(10px,2.2vmin,20px) clamp(14px,3vmin,32px);
    transition: background 0.3s ease, border 0.3s ease;
    -webkit-app-region: no-drag;
  }
  
  .current{
    font-weight:500;
    font-size: clamp(20px,3.6vmin,40px); 
    line-height:1.45;
    letter-spacing:.2px; 
    text-shadow:0 2px 10px rgba(0,0,0,.8);
    min-height:1.2em;
  }
  
  .current.typing .caret{
    display:inline-block; 
    width:.6ch; 
    height:1.05em; 
    transform:translateY(3px);
    background:linear-gradient(180deg,var(--accent1),var(--accent2)); 
    opacity:.8; 
    margin-left:.1ch;
    animation:blink 1s step-end infinite;
  }
  
  @keyframes blink{50%{opacity:0}}
  
  .rule{ 
    margin:8px 0 10px; 
    height:2px; 
    opacity:.55; 
    border-radius:999px;
    background:linear-gradient(90deg,var(--accent1),var(--accent2)); 
  }
  
  .status{
    margin-top: 12px;
    padding: 8px 12px;
    background: transparent;
    border-radius: 8px;
    font-size: 0.9rem;
    opacity: 0.8;
  }
  
  .status.recording{
    background: rgba(76,175,80,.3);
  }
</style>
</head>
<body>
  <div class="content">
    <div class="wrap">
      <div class="controls">
        <div class="server-status">
          <div class="server-indicator" id="serverIndicator"></div>
          <label>서버</label>
        </div>
        <div class="opacity-control">
          <label>투명도</label>
          <input type="range" id="opacitySlider" min="0" max="100" value="0">
          <span id="opacityValue">0%</span>
        </div>
        <button id="closeBtn" type="button" class="close-btn">✕</button>
      </div>
      
      <div class="panel" id="mainPanel" role="region" aria-live="polite" aria-atomic="false">
        <div id="current" class="current typing">
          <span id="currText"></span>
          <span class="caret"></span>
        </div>
        <div class="rule"></div>
        <div id="status" class="status">
          Space 키를 눌러 녹음을 시작/중지하세요
        </div>
      </div>
    </div>
  </div>

<script>
const SILENCE_THRESHOLD = 0.01;
const SILENCE_DURATION = 100;
const MIN_RECORD_DURATION = 500;
const SERVER_URL = 'https://edra-raspiest-eagerly.ngrok-free.dev/stt';

const currEl = document.getElementById('currText');
const current = document.getElementById('current');
const statusEl = document.getElementById('status');
const closeBtn = document.getElementById('closeBtn');
const opacitySlider = document.getElementById('opacitySlider');
const opacityValue = document.getElementById('opacityValue');
const mainPanel = document.getElementById('mainPanel');
const serverIndicator = document.getElementById('serverIndicator');

let isRecording = false;
let mediaRecorder = null;
let audioChunks = [];
let audioContext = null;
let analyser = null;
let silenceStart = null;
let checkInterval = null;
let stream = null;
let recordStartTime = null;
let recordingEnabled = false;
let isServerConnected = false;

function updateServerStatus(connected) {
  isServerConnected = connected;
  if (connected) {
    serverIndicator.classList.add('connected');
  } else {
    serverIndicator.classList.remove('connected');
  }
}

function loadOpacity() {
  const saved = localStorage.getItem('panelOpacity');
  if (saved) {
    opacitySlider.value = saved;
  }
  updateOpacity(saved || 0);
}

function updateOpacity(value) {
  const transparency = value / 100; // 0 = 불투명(원본), 1 = 완전 투명
  const bgOpacity = 1 * (1 - transparency); // 투명도가 높아질수록 배경 투명해짐
  const borderOpacity = 0.15 * (1 - transparency); // 투명도가 높아질수록 테두리 투명해짐
  
  mainPanel.style.background = `rgba(0,0,0,${bgOpacity})`;
  mainPanel.style.borderColor = `rgba(255,255,255,${borderOpacity})`;
  opacityValue.textContent = value + '%';
  localStorage.setItem('panelOpacity', value);
}

closeBtn.addEventListener('click', () => {
  window.close();
});

opacitySlider.addEventListener('input', (e) => {
  updateOpacity(e.target.value);
});

function renderPartial(text){
  current.classList.add('typing');
  currEl.textContent = text || '';
}

function showResult(text){
  const t = (text ?? '').trim();
  if(!t) return;
  
  current.classList.add('typing');
  currEl.textContent = t;
}

function updateStatus(text, isRec = false) {
  statusEl.textContent = text;
  if (isRec) {
    statusEl.classList.add('recording');
  } else {
    statusEl.classList.remove('recording');
  }
}

async function sendToServer(audioBlob){
  try {
    const formData = new FormData();
    formData.append('audio', audioBlob, 'recording.webm');
    
    const response = await fetch(SERVER_URL, {
      method: 'POST',
      headers: {
        'ngrok-skip-browser-warning': 'true'
      },
      body: formData
    });
    
    if(!response.ok){
      const errorText = await response.text();
      console.error('서버 응답:', errorText);
      updateServerStatus(false);
      throw new Error(`HTTP ${response.status}: ${errorText}`);
    }
    
    const result = await response.json();
    updateServerStatus(true);
    
    if(result.success){
      if(result.translated && result.translated !== '(번역 실패)'){
        showResult(result.translated);
      } else {
        showResult(result.original);
      }
    } else {
      throw new Error(result.error || '서버 처리 실패');
    }
    
  } catch(error){
    console.error('STT 에러:', error);
    updateServerStatus(false);
  }
}

function checkAudioLevel() {
  if (!analyser) return;
  
  const bufferLength = analyser.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);
  analyser.getByteFrequencyData(dataArray);
  
  const average = dataArray.reduce((a, b) => a + b) / bufferLength / 255;
  
  if (average < SILENCE_THRESHOLD) {
    if (!silenceStart) {
      silenceStart = Date.now();
    } else if (Date.now() - silenceStart >= SILENCE_DURATION) {
      if (recordStartTime && Date.now() - recordStartTime >= MIN_RECORD_DURATION) {
        stopRecording();
      }
    }
  } else {
    silenceStart = null;
  }
}

async function initStream() {
  if (!stream) {
    try {
      stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioContext.createAnalyser();
      const source = audioContext.createMediaStreamSource(stream);
      source.connect(analyser);
      analyser.fftSize = 2048;
      
    } catch(error) {
      console.error('마이크 접근 에러:', error);
      alert('마이크 접근이 거부되었습니다.\n브라우저 설정에서 마이크 권한을 허용해주세요.');
      throw error;
    }
  }
}

async function startRecording(){
  if(isRecording) return;
  
  try {
    await initStream();
    
    mediaRecorder = new MediaRecorder(stream, {
      mimeType: 'audio/webm'
    });
    audioChunks = [];
    recordStartTime = Date.now();
    
    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        audioChunks.push(event.data);
      }
    };
    
    mediaRecorder.onstop = async () => {
      const duration = Date.now() - recordStartTime;
      
      if (duration >= MIN_RECORD_DURATION && audioChunks.length > 0) {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        await sendToServer(audioBlob);
      }
      
      isRecording = false;
      audioChunks = [];
      silenceStart = null;
      recordStartTime = null;
      
      if (recordingEnabled) {
        setTimeout(() => startRecording(), 100);
      }
    };
    
    mediaRecorder.start();
    isRecording = true;
    updateStatus('🎤 녹음 중... (침묵 감지 시 자동 전송)', true);
    
    if (!checkInterval) {
      checkInterval = setInterval(checkAudioLevel, 10);
    }
    
  } catch(error){
    console.error('녹음 시작 에러:', error);
  }
}

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    mediaRecorder.stop();
  }
}

function cleanupRecording() {
  if (stream) {
    stream.getTracks().forEach(track => track.stop());
    stream = null;
  }
  
  if (audioContext) {
    audioContext.close();
    audioContext = null;
  }
  
  if (checkInterval) {
    clearInterval(checkInterval);
    checkInterval = null;
  }
  
  isRecording = false;
  silenceStart = null;
  updateStatus('Space 키를 눌러 녹음을 시작/중지하세요');
}

window.addEventListener('keydown', (e) => {
  if(e.code === 'Space' && !e.target.matches('input')){
    e.preventDefault();
    
    if (!recordingEnabled) {
      recordingEnabled = true;
      startRecording();
    } else {
      recordingEnabled = false;
      if (isRecording) {
        stopRecording();
      }
      cleanupRecording();
    }
  }
});

loadOpacity();
</script>
</body>
</html>